## 第四章 数据编码与演化

### 数据编码格式

1. 在内存中， 数据保存在对象、 结构体、 列表 、 数组、 哈希表和树等结构中。 这些 数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）。 
2.  将数据写入文件或通过网络发送时， 必须将其编码为某种自包含的字节序列（例 如JSON文档）。 由千指针对其他进程没有意义， 所以这个字节序列表示看起来 与内存中使用的数据结构大不一样 。

#### 语言特定的格式

• 编码通常与特定的编程语言绑定在一起， 而用另一种语言访问数据就非常困难。 如果用这种编码方式存储或传输数据， 可能在很长一段时间内须使用当前的编程 语言， 并且不能将系统与其他组织（可能使用不同的语言）的系统方便地集成在一 起。

 • 为了在相同的对象类型中恢复数据， 解码过程需要能够实例化任意的类。 这经常 导致一些安全问题: 如果攻击者可以让应用程序解码任意的字节序列， 那么它们可以实例化任意的类， 这通常意味着，它们可以做些可怕的事情， 比如远程执 行任意代码。

 • 在这些库中， 多版本数据通常是次要的， 主要目标是快速且简单地编码数据， 所以它们经常忽略向前和向后兼容性等问题。

 • 效率（编码或解码花费的CPU时间， 以及编码结构的大小）通常也是次要的。 例如， Java的内置序列化由于其糟糕的性能和腋肿的编码而广为诉病 。

#### JSON 、 XML与二进制变体

• 数字编码有很多模糊之处。 

• ISON和XML对Unicode字符串（即入类可读文本）有很好的支持， 但是它们不 支持二进制字符串（没有字符编码的字节序列）。

• XML和JSON都有可选的模式支持。 这些模式语言相当强大， 因此学习和 实现起来也比较复杂。 XML模式的使用相当广泛， 但许多基于ISON的工具并不 局限于使用模式。

• CSV没有任何模式， 因此应用程序需要定义每行和每列的含义。 

#### Thrift与Protocol Buffers 

#### 字段标签和模式演化

#### 数据类型和模式演化

#### 模式的优点

• 它们可以比各种 “二进制ISON" 变体更紧凑， 可以省略编码数据中的字段名 称。

 • 模式是一种有价值的文档形式， 因为模式是解码所必需的， 所以可以确定它是最 新的（而手动维护的文档可能很容易偏离现实）。

 • 模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容性。

 • 对千静态类型编程语言的用户来说， 从模式生成代码的能力是有用的， 它能够在 编译时进行类型检查。

### 数据流模式

---

#### 基千数据库的数据流

**不同的时间写入不同的值**    当旧版本的应用程序更新新版本的程序所写入的数据肘， 需要小心， 否则可能会丢失数据

**归档存储**

#### 基于服务的数据流： REST和RPC

面向服务／微服务体系结构的一个关键设计目标是， 通过使服务可独立部署和演化，   让应用程序更易于更改和维护。

**网络服务**

REST不是一种协议， 而是一个基于HTTP原则的设计理念。 它强调简单的数据格式 ， 使用URL来标识资源， 并使用HTTP功能进行缓存控制 、 身份验证和内容类型协商。 与SOAP相比， REST已经越来越受欢迎， 至少在跨组织服务集成的背景下 , 并经常与微服务相关联 。 根据REST原则所设计的API称为RESTful。

相比之下， SOAP是一种基千XML的协议， 用千发出网络API请求 。 虽然它最常用于HTTP, 但其目的是独立于HTTP, 并避免使用大多数HTTP功能。 相反，它带有庞大而复杂的多种相关标准 (Web服务框架， Web Service Framework, 称为WS-*）和新增的各种功能。

**远程过程调用(RPC)的问题**

网络请求与本地函数 调用非常不同：

 • 本地函数调用是可预测的，并且成功或失败仅取决千控制的参数。 网络请求是 不可预测的。请求或响应可能由千网络问题而丢失， 或者远程计算机可能速度慢或不可用， 这些问题完全不在控制范围之内。 网络问题很常见， 因此必须有所准备， 例如重试失败的请求。 

• 本地函数调用要么返回一个结果， 要么抛出一个异常， 或者永远不会返回（因为进入无限循环或者进程崩溃）。 网络请求有另一个可能的结果：由于超时， 它返回时可能没有结果。 在这种情况下， 根本不知道发生了什么： 如果没有收到来自远程服务的响应， 无法知道请求是否成功。

• 如果重试失败的网络请求， 可能会发生请求实际上已经完成， 只是响应丢失的情况。在这种情况下， 重试将导致该操作被执行多次， 除非在协议中建立重复数据消除（幕等性机制。本地函数调用则没有这样问题。

 • 每次调用本地函数时， 通常需要大致相同的时间来执行。网络请求比函数调用要慢得多， 而且其延迟也有很大的变化：情况好时， 它可能会在不到1ms的时间内完成， 但是当网络拥塞或者远程服务过载时， 可能需要几秒钟的时间才能完成相同操作。

 • 调用本地函数时，可以高效地将引用（指针）传递给本地内存中的对象。当发出网络请求时， 所有这些参数都需要被编码成可以通过网络发送的字节序列。如果参数是像数字或字符串这样的基本类型， 这没关系， 但是对于较大的对象很快就会出现问题。

 • 客户端和服务可以用不同的编程语言来实现， 所以RPC框架必须将数据类型从一 种语言转换成另 一种语言。因为不是所有的语言都具有相同的类型， 所以最终可能会丑陋。

#### 基于消息传递的数据流

与直接RPC相比，使用消息代理有以下几个优点：

 • 如果接收方不可用或过载，它可以充当缓冲区，从而提高系统的可靠性。

 • 它可以自动将消息重新发送到崩溃的进程，从而防止消息丢失。

 • 它避免了发送方需要知道接收方的IP地址和端口号（这在虚拟机经常容易起起停停的云部署中特别有用）。

 • 它支持将一条消息发送给多个接收方。

 • 它在逻辑上将发送方与接收方分离（发送方只是发布消息，并不关心谁使用它们）。

**分布式Actor框架**

三种流行的分布式Actor框架处理消息编码的方式如下：

 • 默认情况下， Akka使用Java的内置序列化， 它不提供向前或向后兼容性。 但是， 可以用类似Protocol Buffers的东西替代它， 从而获得滚动升级的能力  。

 • 默认情况下， Orleans使用不支持滚动升级部署的自定义数据编码格式；要部署新版本的应用程序， 需要建立一个新的集群， 将流晕从旧集群导入到新集群， 然后关闭旧集群。 像Akka一样， 也可以使用自定义序列化插件。

 • 在Erlang OTP中， 很难对记录模式进行更改（尽管系统具有许多为高可用性而设计的功能）。 滚动升级在技术上是可能的， 但要求仔细规划  。 一些实验性的新型映射数据类型(2014年在Erlang R17中引入的类似千JSON的结构）可能会使模式的更改在将来变得更容易。