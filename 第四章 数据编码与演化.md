## 第四章 数据编码与演化

### 数据编码格式

1. 在内存中， 数据保存在对象、 结构体、 列表 、 数组、 哈希表和树等结构中。 这些 数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）。 
2.  将数据写入文件或通过网络发送时， 必须将其编码为某种自包含的字节序列（例 如JSON文档）。 由千指针对其他进程没有意义， 所以这个字节序列表示看起来 与内存中使用的数据结构大不一样 。

#### 语言特定的格式

• 编码通常与特定的编程语言绑定在一起， 而用另一种语言访问数据就非常困难。 如果用这种编码方式存储或传输数据， 可能在很长一段时间内须使用当前的编程 语言， 并且不能将系统与其他组织（可能使用不同的语言）的系统方便地集成在一 起。

 • 为了在相同的对象类型中恢复数据， 解码过程需要能够实例化任意的类。 这经常 导致一些安全问题: 如果攻击者可以让应用程序解码任意的字节序列， 那么它们可以实例化任意的类， 这通常意味着，它们可以做些可怕的事情， 比如远程执 行任意代码。

 • 在这些库中， 多版本数据通常是次要的， 主要目标是快速且简单地编码数据， 所以它们经常忽略向前和向后兼容性等问题。

 • 效率（编码或解码花费的CPU时间， 以及编码结构的大小）通常也是次要的。 例如， Java的内置序列化由于其糟糕的性能和腋肿的编码而广为诉病 。

#### JSON 、 XML与二进制变体

• 数字编码有很多模糊之处。 

• ISON和XML对Unicode字符串（即入类可读文本）有很好的支持， 但是它们不 支持二进制字符串（没有字符编码的字节序列）。

• XML和JSON都有可选的模式支持。 这些模式语言相当强大， 因此学习和 实现起来也比较复杂。 XML模式的使用相当广泛， 但许多基于ISON的工具并不 局限于使用模式。

• CSV没有任何模式， 因此应用程序需要定义每行和每列的含义。 

#### Thrift与Protocol Buffers 

#### 字段标签和模式演化

#### 数据类型和模式演化

#### 模式的优点

• 它们可以比各种 “二进制ISON" 变体更紧凑， 可以省略编码数据中的字段名 称。

 • 模式是一种有价值的文档形式， 因为模式是解码所必需的， 所以可以确定它是最 新的（而手动维护的文档可能很容易偏离现实）。

 • 模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容性。

 • 对千静态类型编程语言的用户来说， 从模式生成代码的能力是有用的， 它能够在 编译时进行类型检查。