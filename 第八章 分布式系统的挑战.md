# 第八章 分布式系统的挑战

## 故障与部分失效



要使分布式系统可靠工作，就必然面对部分失效，这就需要依靠软件系统来提供容错

机制。只要软件试图跨节点做任何事情， 就有可能出现失败， 或者随机变慢， 或者根本无应答（最终超时）。

## 不可靠的网络

通过网络连接到各个节点，发送之后等待响应过程中， 网络会遇到一些问题：

1. 请求丢失（有人拔了网线）
2. 请求正在队列中等待
3. 远程接受节点失效
4.  远程接收节点可能暂时无法响应
5. 远程接收节点已经完成了请求处理， 但回复却在网络中丢失
6. 远程接收节点已经完成了请求处理， 但回复却被延迟处理

处理这个问题通常采用超时机制：在等待一段时间之后， 如果仍然没有收到回复则选择放弃， 并且认为响应不会到达

### 同步与异步网络

传统的固定电话网络本质是同步的：即使数据中间经过了多个路由器，16bit空间在电路建立时已经在网络中得到预留， 不会受到排队的影响。 由千没有排队，网络最大的端到端延迟是固定的。 我们称之为有界延迟。

## 不可靠的时钟

时钟和计时非常重要，应用中的有些功能十分依赖于时钟，由于跨节点通信不可能即时完成， 消息经由网络从一台机器到另一台机器总是需要花费时间，网络有延迟而且不确定性，经常无法判断结点通信先后顺序。

### 单调时钟和墙上时钟

单调时钟：单调时钟更适合测晕持续时间段（时间间隔）， 例如超时或服务的响应时间： Linux 上的clock_gettime (CLOCK_MONOTONIC) 和Java中的System.nanoTime() ，返回的即是单调时钟。

墙上时钟：根据某个日历（也称为墙上时间）返回当前的日期与时间。例如Java中的  System.*currentTimeMillis*()

### 时钟同步与准确性

### 依赖同步的时钟

**时间戳与事件顺序**

跨节点的事件排序， 如果它高度依赖时钟计时， 就存在一定的技术风险。

## 进程暂停

一个线程可能会暂停这么长时间么？这是可能的， 发生这种情况的原因很复杂，分布式系统中的一个节点必须假定， 执行过程中的任何时刻都可能被暂停相当长一段时间， 包括运行在某个函数中间。 暂停期间， 整个集群的其他部分都在照常运行， 甚至会一致将暂停的节点宣告为故障节点。 最终， 暂停的节点可能会回来继续运行， 除非再次检查时钟， 否则它对刚刚过去的暂停毫无意识。







## 主节点与锁

只允许一个节点作为数据库分区的主节点。防止脑裂。

同一时间，只允许一个客户端执行事务或获取锁。

只允许一个用户来使用特定的用户名， 从而确保用户名可以唯一标识用户。

### 拜占庭故障

假设节点虽然不可靠但一定是诚实的： 它们尽管运行很慢或者由于故障而无法响应， 或者状态可能已经过期（例如由于GC暂停或网络延迟）， 但一且做出了响应， 则一定是完全基于其所知的全部信息和事先协议约定好的行为准则， 响应代表了 其所知的 “真相”，这种行为称为拜占庭故障。