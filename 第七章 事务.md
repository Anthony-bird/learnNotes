## 第七章 事务

**事务**将应用程序的多个读写操作捆绑在一起成为一个逻辑操作单元，即事务中的所有读写都是一个执行整体，要么都成功（提交），要么都失败（中止或回滚）。如果失败，应用程序可以安全地进行重试。



### 深入理解事务

#### 事务的特性：ACID

**事务所提供的安全性保证就是 ACID**，即**原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）以及持久性（Durability）**。



##### 原子性

原子性的特征是：在发生故障时中止事务，并将部分完成的写入全部丢弃。



原子性主要针对的是客户端发起一个包含多个写操作的请求时，应该如何处理写入失败的情况。若一系列写操作中间发生错误，则事务必须中止，且事务中已经成功写入的部分应该被丢弃，事务必须回滚。也就是说，对于一个事务来说，不用担心数据库的部分失败，它总是保证要么全部成功，要么全部失败。

##### 一致性

一致性主要是指对数据有特定的预期状态，任何数据的更改必须满足这些状态约束。



应用程序需要正确定义应用程序中的事务以及它的一致性表现。数据复制也有数据一致性问题，但是二者并不相同。数据复制的数据一致性是数据库层面，而事务的一致性是应用层层面。

##### 隔离性

隔离性意味着多个事务相互隔离，互不干涉。这2个事务是可以并行执行的，但是事务提交时，其结果要和串行执行完全相同，因此隔离性也定义为可串行化。例如，某个事务进行多次写入，则另外一个事务应该能够观察到的是其全部完成（或者一个都没完成）的结果，而不应该看到中间结果。

隔离性解决的主要是如何处理多个事务并发写同一个数据的问题（存在竞态条件）。这其实很像多线程中的并发问题。

##### 持久性

数据库的核心功能是保存存储的数据不丢失。



持久性就是指，事务一旦提交成功，即使存在硬件故障或者数据库崩溃，事务写入的数据也不会消失。



在单节点的情况下，持久性意味着写入非易失性存储，例如硬盘或者 SSD。对于多节点来说，则意味着数据已经同时复制到多个节点，才能认为持久化成功了。



#### 单对象与多对象事务操作

对于关系数据模型， 表中的某行可能是另一个表中的外键。

对于文档数据模型， 如果待更新的字段都在同一个文档中， 则可视为单个对象， 此时不需要多对象事务。 但是， 缺少join支持的文档数据库往往会滋生反规范化，当更新这种非规范化数据时， 就需要一次更新多个文档。 此时多对象事务就可以有效防止非规范化数据之间出现不同步。

对于带有二级索引的数据库（除了纯粹键－值存储以外几乎所有其他系统都支持二级索引）， 每次更改值时都需要同步更新索引。 从事务角度来看， 这些索引是不同的数据库对象：如果没有事务隔离， 就会出现部分索引更新。

#### 隔离级别

**脏读**

客户端读到了其他客户端尚未提交的写入。 读－提交以及更强的隔离级别可以防 止脏读。 

**脏写** 

客户端覆盖了另 一个客户端尚未提交的写入。 几乎所有的数据库实现都可以防止 脏写。

**读倾斜（不可重复读）** 

客户在不同的时间点看到了不同值。 快照隔离是最用的防范手段， 即事务总是 在某个时间点的一致性快照中读取数据。 通常采用多版本并发控制(MVCC)来 实现快照隔离。 

**更新丢失** 

两个客户端同时执行读－修改－写入操作序列， 出现了其中一个覆盖了另一个的写 入， 但又没有包含对方最新值的情况， 最终导致了部分修改数据发生了丢失。 快 照隔离的一些实现可以自动防止这种异常， 而另 一些则需要手动锁定查询结果 (SELECT FOR UPDATE)。 

**写倾斜** 

事务首先查询数据， 根据返回的结果而作出某些决定， 然后修改数据库。 当事务提交时， 支持决定的前提条件已不再成立。 只有可串行化的隔离才能防止这种异常。

**幻读** 

事务读取了某些符合查询条件的对象， 同时另一个客户端执行写入， 改变了先前 的查询结果。 快照隔离可以防止简单的幻读， 但写倾斜情况则需要特殊处理， 例 如采用区间范围锁。

实现**可串行化隔离**的三种不同方法：

**严格串行执行事务** 

如果每个事务的执行速度非常快， 且单个CPU核可以满足事务的吞吐量要求， 严格串行执行是一个非常简单有效的方案。

**两阶段加锁** 

几十年来， 这一直是实现可串行化的标准方式， 但还是有很多系统出于性能原因而放弃使用它。 

**可串行化的快照隔离**(SSI)

 一种最新的算法， 可以避免前面方法的大部分缺点。 它秉持乐观预期的原则， 允许多个事务并发执行而不互相阻塞；仅当事务尝试提交时， 才检查可能的冲突， 如果发现违背了串行化， 则某些事务会被中止。