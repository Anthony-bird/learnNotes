# 数据存储与检索

**数据库核心： 数据结构**

适当的索引可以加速读取查询， 但每个索引都 会减慢写速度。为此， 默认情况下， 数据库通常不会对所有内容进行索引， 它需要应 用开发人员或数据库管理员， 基千对应用程序典型查询模式的了解， 来手动选择索 引。 目的是为应用程序提供最有利加速的同时， 避免引入过多不必要的开销。

**哈希索引**

文件格式 CSV不是日志的最佳格式。 更快更简单的方法是使用二进制格式， 首先以字节为单位来记录字符串的长度， 之后跟上原始字符串（不需要转义）。

**删除记录**

 如果要删除键和它关联的值， 则必须在数据文件中追加一个特殊的删除记录（有 时候称为墓碑）。 当合并日志段时， 一且发现墓碑标记， 则会丢弃这个已删除键 的所有值。 

**崩溃恢复** 

如果数据库重新启动， 则内存中的hash map将丢失。 原则上， 可以通过从头到 尾读取整个段文件， 然后记录每个键的最新值的偏移量， 来恢复每个段的hash map。 但是， 如果分段文件很大， 可能扫描需要很长时间， 这将使服务器重启变 得缓慢。 Bitcask通过将每个段的hash map的快照存储在磁盘上， 可以更快地加载 到内存中， 以此加快恢复速度。 

**部分写入的记录** 

数据库随时可能崩溃， 包括将记录追加到日志的过程中。 Bitcask文件包括校验 值， 这样可以发现损坏部分并丢弃。 

**并发控制** 

由千写入以严格的先后顺序追加到日志中， 通常的实现选择是只有一个写线程。 数据文件段是追加的， 并且是不可变的， 所以他们可以被多个线程同时读取。

**SSTables和LSM-Tree**

SSTable相比哈希索引的日志段， 具有以 下优点： 

1. 合并段更加简单高效， 即使文件大于可用内存。 方法类似千合并排序算法中使用 的方法， 如图3-4所示。 并发读取多个输入段文件， 比较每个文件的第一个键， 把最小的键（根据排序顺序）拷贝到输出文件， 并重复这个过程。 这会产生一个 新的按键排序的合并段文件。 如果相同的键出现在多个输入段怎么办？请记住， 每个段包含在某段时间内写入 数据库的所有值。 这意味着一个输入段中的所有值肯定比其他段中的所有值更新 （假设总是合并相邻的段）。 当多个段包含相同的键时， 可以保留最新段的值， 并丢弃旧段中的值。

2. 在文件中查找特定的键时， 不再需要在内存中保存所有键的索引。 以图3-5为 例， 假设正在查找键handiwork, 且不知道该键在段文件中的确切偏移。 但 是， 如果知道键handbag和键handsome的偏移显， 考虑到根据键排序， 则键 handiwork一定位千它们两者之间。 这意味着可以跳到handbag的偏移， 从那里开 始扫描， 直到找到handiwork (如果键handiwork不存在文件中， 那么找不到）。

**构建和维护SSTables**

存储引擎的基本工作流程如下：

 • 当写入时， 将其添加到内存中的平衡树数据结构中（例如红黑树）。 这个内存中 的树有时被称为内存表。

 • 当内存表大千某个阑值（通常为几兆字节）时， 将其作为SSTable文件写入磁 盘。 由于树已经维护了按键排序的key-value对， 写磁盘可以比较高效。 新的 SSTable文件成为数据库的最新部分。 当SSTable写磁盘的同时， 写入可以继续添 加到一个新的内存表实例。 

• 为了处理读请求， 首先尝试在内存表中查找键， 然后是最新的磁盘段文件， 接下 来是次新的磁盘段文件， 以此类推， 直到找到目标（或为空）。

 • 后台进程周期性地执行段合并与压缩过程， 以合并多个段文件， 并丢弃那些已被 覆盖或删除的值。

**从SSTables到LSM-Tree**

**性能优化**

**B-trees**

**使B-tree可靠**

**优化B-tree**

**对比B-tree和LSM-tree**

**LSM-tree的优点**

在许多SSD上， 固件内部使用日志结构化算法将随机写入转换为底层存储芯片上的顺 序写入， 所以存储引擎写入模式的影响不那么明显( 19]。 然而， 更低的写放大和碎片减 少对于SSD上仍然有益， 以更紧凑的方式表示数据， 从而在可用的I/0带宽中支持更多 的读写请求。

**LSM-tree的缺点**

日志结构存储的缺点是压缩过程有时会干扰正在进行的读写操作。

**列式存储**

**列压缩**

**聚合：数据立方体与物化视图**